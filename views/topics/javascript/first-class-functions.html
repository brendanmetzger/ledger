<article id="first-class-function">
  <script type="text/javascript">
    // <![CDATA[
      bloc.embed('/javascript/examples/bread.js');
    // ]]>
  </script>
  <h2>First-class Functions</h2>
  <section class="three columns indented">
    <p>From a linguistic perspective, <em>functional programming</em> may seem to be nothing more than <q>writing a program with functions</q>, but this not accurate—all programs are written with functions in a simple term. Functional programming hellbent on austerity. Conversely, in <em>imperative programming</em>, we solve problems as straightforward as possible; sequentially through loops, conditions and function calls. Functional programs solve problems only <em>with functions</em>, largely out of sequence and order. While we will use the imperative style to solve our problems I’m introducing the contrast between them because JavaScript can be a be clever and applies many <em>functional concepts</em>; such cleverness can be frustrating depending on your level of experience.</p>
    <p>A <a href="https://en.wikipedia.org/wiki/First-class_function">first-class function</a> is a fundamental part of the language, like our types (number, string, boolean, etc). Compare the two greeting variables in the following example and note that we can stuff a function into a variable.</p>
    <pre class="prettyprint" style="break-inside: avoid;">
      <!-- review views/javascript/examples/bread.js functions as values  -->
    </pre>
    <p>This no doubt looks a bit odd, but the important thing to notice is that both examples produce a similar outcome: they assign a <code>string</code> with a typical english greeting to a variable, but they take a very different approach. Just like a <code>number</code> indicates quantitative property, such as measurement, <code>function</code> represents an action to take place. However, that action does not take place until you call the function with the <code>()</code> operator. In this example, I'm doing that immediately after I declare the function body (which is some of the cleverness I mentioned earlier).</p>
    <p>A function starts as an idea of something to be done written in the function definition. Once <strong>defined</strong>, it can be <strong>executed</strong> at any time to produce value. Pause there: it produces a value by <strong>returning</strong> something; numbers, strings, booleans, arrays, objects, even other functions! This is the <em>first-class</em> shenanigans I'm talking about: functions can be tossed around like any other type.</p>
  </section>
  
  <section class="explain whitepaper">
    <aside class="note">
      <h3>The Chicken or the Egg</h3>
      <p>Because of its first-class nature, a function can be stored in a variable, in a data structure like an array or an object. A function can be passed as an argument to another function. A function can return another function (a tenet of any language implementing first-class functions). While many languages support these features and allow you to utilize them, JavaScript <em>requires</em>.</p>
      <p>In this example you will notice a function returning a function. What happens when I execute the <code>Chicken()</code> function? What do I get back? How about an <code>Egg()</code>?</p>
      <p>This is a riddle;  play with it in the console for awhile until you get the hang of it. The premise, though simple, is intriguing: whenever you call a function, you will always get back another function. That means, you can keep using the <code>()</code> operator over and over and over.</p>
    </aside>
    <pre class="prettyprint">
      <!-- review views/javascript/examples/functions.js chicken or the egg -->
    </pre>
  </section>
  
  <script type="text/javascript">
    bloc.embed('/javascript/examples/bread.js');
  </script>
</article>
