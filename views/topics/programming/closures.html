<article>
  <header>
    <h1><code>this</code> is important</h1>
    <h2>A foray into function binding and closures</h2>
    <p>I ran across an article called <a href="http://alistapart.com/article/getoutbindingsituations">Getting Out of Binding Situations in JavaScript</a> (written some years ago) and realized that programming how-to articles are sometimes heavy on solution and a little light on perspective. Without perspective, people quickly become dogmatic and rightous and maybe even a tad confused, so before taking anything as gospel, let's use the example I culled in that article and give <em>more</em> prespective (assuming you may read that one as well).</p>
  </header>

  <p>Let's start right in with a tidbit of code – code that indicates we are in a bit of a pickle due to scope, and two different solutions to get us out of that pickle. Boiled way down, we have two nearly similar pieces of code, starting with the left; <q>...Notice the trailing call to bind. However, such code is not as good an idea as it may seem. We saw that achieving such a “bound reference” requires us to wrap the original method within an anonymous function, which means calling the bound method reference results in two method calls: our anonymous wrapper, and the original method.</q></p>

  <section class="comparison container">
    <pre class="prettyprint half float left">
      processItems: function() {
        // Look right approximately here
        this.items.each(function(item) {
          // Process item
          this.markItemAsProcessed(item);
        }.bind(this));
      }
    </pre>


    <pre class="prettyprint half float left">
      processItems: function() {
        var that = this;
        this.items.each(function(item) {
          // Process item
          that.markItemAsProcessed(item);
        }); // look left approximately here
      }
    </pre>
  </section>

  <p>Now lets look at the improved solution on the right. <q>This code uses a language feature called “lexical closure.”</q> and it is an improvement because <q>...it would be far less than the cost of an extra function call at every turn of the loop</q>. More or less efficient, I really don't know, but the extra function call referred to is from <code>.bind(this)</code>, and from the perspective on when this was written, that might be true (probably not today). The author mentions how jQuery implements this philosophic principle on scope resolution for good reason, but I'm going to try and demonstrate a counterpoint that even if not preferred, should be understood as fully as possible, which is: <strong>if you are using <code>this</code>, keep <code>this</code> relevant.</strong></p>


  <p>I'm going to be a dilletante and announce that <code>Function.bind</code> was a brilliant addition to ES5, and for the frameworks implementing it sooner as a prototypal method (Prototype, MooTools), bless your hearts for showing me the way. The code below shows my version of how I'd use bind (then and now) to counterpoint the example code earlier. Just read it to yourself 5 times, and if it makes less sense than either of the solutions posed above, I'll concede. If curiosity starts to build about this 'bind' stuff being quite valuable, continue please.</p>

  <section class="comparison container">
    <pre class="prettyprint half float left">
      processItems: function() {
        var that = this;
        this.items.each(function(item) {
          // Process item
          that.markItemAsProcessed(item);
        });
      }
    </pre>
    <pre class="prettyprint half float left">
      processItems: function() {
        this.items.each(this.markItemAsProcessed.bind(this));
      }
    </pre>

  </section>



  <h2>Making examples is hard</h2>
  <p>Now, for a beginner, the article presented things that you would not pick up on, and I'll pick at this because it does favor one solution over another in terms of performance, and in that spirit, it should be pointed out that for the example given, both <em>lexical closure</em> and <code>bind</code> are unnecessary. In fact, my counterpoint to the previous example almost elucidates that. Going backwards a few steps, let's look at the example that is correct but in the context of talking about scope but misleads you in the actual optimization. From the article, the only reason we need <em>lexical closure</em> or <em>binding</em> is because of that pesky <em>anonymous function</em> in our <code>each</code> method: <q>This code will trigger an error stating that the <code>markItemAsProcessed</code> method is undefined</q><sup><a href="#_1">1</a></sup>. That code is below on the left.</p>



  <section class="comparison container" title="Given Example">
    <pre class="prettyprint half float left">
      this.items.forEach(function(item) {
        // typeError – dunno what `this` is..
        this.markItemAsProcessed(item);
      });
    </pre>

    <pre class="prettyprint half float left" title="Refactored Example">
      // `this` references are in same scope here
      this.items.forEach(this.markItemAsProcessed);
    </pre>
  </section>

  <p>Now, we fixed the typeError that immediately with the example on the right. Also, by way of the author's (probably true) reasoning, it will be <em>even more efficient</em> because it makes one less function call. Now, I'm not doing this to point out egg on someone's face, just giving the introduction to this notion: in JavaScript we pass functions around like they are contageous, and we can manipulate them long after they are declared, giving us something we'll casually – though not officially – call <em>'dynamic scope'</em>. The ongoing goal of this lecture is to highlight situations where you can use either closure (lexical) or binding ('dynamic') scope and getting the difference betwixt the two. Programming is expressive and interesting, and the fact that JavaScript offers so many techniques makes it even more expressive in my opinion.</p>


  <h2>Functions beget functions</h2>
  <p>What is <code>Array.forEach</code> anyway? First, it takes a function, any function – named or anonymous – as the first argument and calls that function for every index of the array. Glancing at the homemade version below reminds us that <code>Array.forEach</code> is itself a function, thus, <em>it has it's own scope</em>, and because of that – and for for sake of simplicity – let's just say that our callback will not have the scope that it had where <em>we wrote it</em> (lexical). Moreover, the human brain and eyeballs we use to scan a program's source code will probably lose track of "lexical scope" at this point, we fuck up, and opt to stare cross-eyed at the nonsense in front of us while muttering obsenities about how JavaScript is dumb. Rather than do that over and over, let's right now make a pithy rule of thumb called the <strong>callback principle</strong>: functions, anonymous or otherwise, passed as arguments to other functions will have their scope mangled; it will elude you; it will trick your eyeballs; predict it happening before it foils you.</p>

  <pre class="prettyprint">
    Array.prototype.forEach = function(callback, context) {
      for (var i = 0; i &lt; this.length; i+=1) {
        // the scope where callback came from
        // doesn't matter b/c it's called HERE
        callback.call(context, this[i]);
      }
    };
  </pre>

  <p>Do note, in the code above, the the array itself is <code>this</code> from <code>forEach</code>'s perspective (which makes sense). Also, if you don't understand the difference between <em>passing</em> a named or anonymous function and <em>executing</em> a function, revist the <a href="lecture/index/programming/functions">function lecture</a></p>

  <h2>Beginner languages and <em>Lambda Abstractions</em></h2>
  <p>JavaScript is frustrating for many people, and I think it starts with the fact that instead of a slow and steady introduction to anonymous functions and closures – which are a bit more niche in other popular languages – one is thrust into that way of thinking right away through necessity of important JavaScript functions like <code>setTimeout</code> and <code>addEventListener</code>. Further, <code>this</code> does not work as straight-forward as it does in class-based definitions; it can <em>and must</em> be manipulated to implement object-oriented JavaScript. <strong>Every scope has a <code>this</code>; every function creates a scope; <code>this</code> represents the calling object from that scope.</strong></p>


  <h2>Elegance, is a virtue</h2>
  <p>In the examples to follow, we will assume <em>lexical scope</em> and/or <code>this</code> resolution is quite necessary. Referencing the code below, note that in the body of <code>markItemAsProcessed</code>, it requires access to its containing object via <code>this</code>; the object that defines and implements the <code>items</code> property and the <code>processItems</code> method. Since we know what this object is, we should go ahead and use <code>this</code> and keep things <a href="https://en.wikipedia.org/wiki/Loose_coupling">loosly coupled</a>. In their entirety, these examples employ a list of items, and have a method that can 'process' them all at once, which in this instance, is pushing them into an <code>Array</code> called 'processed'. Here are two techniques, one using scoped variables, and the other binding <code>this</code>.</p>




  <section class="explain container">

    <pre class="prettyprint half float left">
      items: ['a', 'b', 'c'],
      processed: [],
      processItems: function() {
        var that = this;
        this.items.forEach(function(item) {
          // Process item
          that.markItemAsProcessed(item);
        });
      },
      markItemAsProcessed: function(item) {
        this.processed.push(item);
      }
    </pre>



    <aside class="half float left">
      <h4>Design thinking to process items: Using a closure</h4>
      <ol>
        <li>Iterate through items using a <code class="A">Array.forEach</code> passing an <span class="B">anonymous function</span> as the callback argument</li>
        <li>execute <code>this.markItemAsProcessed</code> each time within the callback</li>
        <li><code>Array.forEach</code> will dereference <code>this</code> within our anonymous function by way of the aforementioned <strong>callback principle</strong></li>
        <li>Assign a scoped variable called <code>that</code> outside of function; <code>this</code> is now accessible via scoped <code>that</code>.</li>
        <li>Call <code>that.markItemAsProcessed</code> with the item argument from the outer anonymous callback function.</li>
      </ol>
    </aside>
  </section>


  <section class="explain container">
    <pre class="prettyprint half float left">
      items: ['a', 'b', 'c'],
      processed: [],
      processItems: function() {
        this.items.forEach(this.markItemAsProcessed.bind(this));
      },
      markItemAsProcessed: function(item) {
        this.processed.push(item);
      }
    </pre>
    <aside class="half float left">
      <h4>Design thinking to process items: Using bound function</h4>
      <ol>
        <li>Iterate through items using <code>Array.forEach</code> and the instance method <code>markItemAsProcessed</code> as the callback argument</li>
        <li>NOTE: <code>markItemAsProcessed</code> uses <code>this</code> internally – it is defined in <strong>same scope</strong> as <code>processItems</code></li>
        <li><code>Array.forEach</code> will defeference <code>this</code> within <code>this.markItemAsProcessed</code> by way of the aforementioned <strong>callback principle</strong></li>
        <li>Because of #2, explicitely bind <code>this</code> to <code>this.markItemAsProcessed</code></li>
      </ol>
    </aside>
  </section>


  <p>Introducing <code>var that = this;</code> doesn't do anything bad, but it <em>doesn't</em> do something that the second version does, and something that I consider quite beneficial. First, it is not that there is one less step in the second example – that is not an advantage, nor should concision be a goal when writing elegant or maintainable code. I prefer the design thinking of the second one because of the introduction and consideration of #2 - which never has a clear spot to introduce itself in the first example – at least it didn't to me. I was more focused on examining the scope/closure of my <em>anonymous function</em> than thinking about the context of <code>this</code> in my <em>entire object</em>.</p>

   <p>Further, swapping around <code><strong>that</strong>.doingSomething</code> is a bit of linguistic subterfuge – I prefer  to stay focused on <code><strong>this</strong>.doingSomething</code>. I think a reference to <code>this</code> is something you keep track of wholistically, whereas variable scope has a more myopic role; in fact you literally need to see where things in the code are defined to put the pieces back together (by definiton of <em>lexical scope</em>). Now in a more opinionated fashion, using variables as references to <code>this</code> messes with my intuition regarding demonstrative pronouns, and choosing another variable name is all the same to me: <code><strong>(this|obj|super|whatever)</strong>.doingSomething</code> can't trump the pristine focus of <code><strong>this</strong>.doingSomething</code> – as long as I stay windful of what <code>this</code> is.</p>

  <h2>A working version</h2>

  <section class="container">
    <pre class="prettyprint half float left">
(function () {
  'use strict';

  function ItemProcessor() {
    return {
      items: ['a', 'b', 'c'],
      processed: [],
      processItems: function() {
        var that = this;
        this.items.forEach(function(item) {
          // Process item
          that.markItemAsProcessed(item);
        });
      },
      markItemAsProcessed: function(item) {
        this.processed.push(item);
      }
    }
  }
})();
    </pre>

    <pre class="prettyprint half float left">
(function () {
  'use strict';

  function ItemProcessor() {
    return {
      items: ['a', 'b', 'c'],
      processed: [],
      processItems: function() {
        this.items.forEach(this.markItemAsProcessed.bind(this));
      },
      markItemAsProcessed: function(item) {
        this.processed.push(item);
      }
    }
  }
})();
    </pre>


    <hr class="clear"/>

    <pre class="prettyprint half float left">
      var obj = ItemProcessor();
      obj.processItems();
      obj.markItemAsProcessed(obj.items[0]);
      console.log(obj.processed);
    </pre>

    <aside class="half float left">
      <h4>Input/Output</h4>
      <p>Both functions do the exact same things in the exact level of "correctness" according to the author's (me, in this case) intentions. Output <code>item.processed === ['a', 'b', 'c', 'a']</code> and have the same interface. Output available in console.</p>
    </aside>
  </section>


  <p>My last note, even though both examples work, in the non-bind way, I got there by trial and error because I didn't expect it to work the way it is written (ie, I was shoving more references to <code>that</code> in than I needed). This is a full concession to perhaps my weakness in understanding scope, but after calling <code>that.markItemAsProcessed</code> and then looking back into the actual <code>markItemAsProcessed</code> function definiton, I'm always a bit bemused to understand how it knows what <code>this</code> references. Then I look at it for awhile, and go "ohhhh! right...". Then I repeat my confusion a little later.</p>

  <h2>The takeaway, regardless of technique</h2>
  <p>We can maintain scope through closures, or more appropriately <em>lexical scope</em>. This is a fancy way of saying, "where the code was written" or "determined at write time". Now, while I've heard that it's not technically <em>dynamic scope</em>, setting <code>this</code> via <code>Function.bind</code> or <code>Functon.call</code> gets us kind of close to something like dynamic scope, and that is, scope that is determined "where the function was called", and in that way, it is "read time". Alternatively, in my loosest way possible, binding lets you mess around with functions that already exist... functions that maybe you didn't even write! (example below)</p>

  <pre class="prettyprint">
    // say we have a nodelist of all paragraph Elements
    var elems = document.querySelectorAll('p');

    // we love `forEach`, but nodelist has no sech method.
    elems.forEach(callback); // TypeError ... .forEach is not a function

    // Array has a forEach method, let's poach it with `call`.
    [].forEach.call(elems, callback); // works!
  </pre>

  <script type="text/javascript">
    //<![CDATA[
    (function () {
      'use strict';

      function ItemProcessor() {
        return {
          items: ['a', 'b', 'c'],
          processed: [],
          processItems: function() {
            var that = this;
            this.items.forEach(function(item) {
              // Process item
              that.markItemAsProcessed(item);
            });
          },
          markItemAsProcessed: function(item) {
            this.processed.push(item);
          }
        }
      }

      var obj = ItemProcessor();
      obj.processItems();
      obj.markItemAsProcessed(obj.items[0]);
      console.log('that', obj.processed);

    })();


    (function () {
      'use strict';
      function ItemProcessor() {
        return {
          items: ['a', 'b', 'c'],
          processed: [],
          processItems: function() {
            this.items.forEach(this.markItemAsProcessed.bind(this));
          },
          markItemAsProcessed: function(item) {
            this.processed.push(item);
          }
        }
      }

      var obj = ItemProcessor();
      obj.processItems();
      obj.markItemAsProcessed(obj.items[0]);
      console.log('bind', obj.processed);

    })();

    //]]>
  </script>
  <footer>
    <h3>Important Terms</h3>
    <dl>
      <dt>lexical</dt>
      <dd>of or relating to the words or vocabulary of a language: lexical analysis.</dd>
      <dd><em>in computing</em>: is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an identified "meaning").</dd>
      <dt>Pissing Contest</dt>
      <dd>"a competition to see who can urinate the farthest or highest"</dd>
      <dd>"Any contest which is futile or purposeless especially ones pursued in a conspicuously aggressive manner"</dd>
      <dt>Lexical Scope</dt>
      <dd>Will be referred to as <em>scope</em> from here on</dd>
      <dd><a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">from wikipedia</a>: The term "scope" is also used to refer to the set of all entities that are visible or names that are valid within a portion of the program or at a given point in a program... Strictly speaking and in practice for most programming languages, "part of a program" refers to "portion of the source code (area of text)"</dd>
    </dl>
    <ul>
      <li id="_1"><sup>1</sup><a href="http://alistapart.com/article/getoutbindingsituations#snippet8">Snippet</a></li>
    </ul>
  </footer>

</article>
