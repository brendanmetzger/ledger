<article>
  <header>
    <h1>Criticisms</h1>
    <h2>You can't believe everything you read on the internet.</h2>

    <p>I ran across an article called <a href="http://alistapart.com/article/getoutbindingsituations">Getting Out of Binding Situations in JavaScript</a> written some years ago and realized that programming advice resources can be a bit misleading. More importantly, this comes from a pretty well respected source of advice, so it's always good to turn your head a bit sideways before taking anything as gospel.</p>
  </header>
  <p>First off, let me say, the original author of this article is easily 5-7 times smarter than me and this was written some years ago, os I'm not intending to be a douche, but simply diagram what I noticed right away.</p>
  <p>Here is an example of something one guy said is bad because <q>...Notice the trailing call to bind. However, such code is not as good an idea as it may seem. We saw that achieving such a “bound reference” requires us to wrap the original method within an anonymous function, which means calling the bound method reference results in two method calls: our anonymous wrapper, and the original method.</q></p>
  <pre class="prettyprint lang-js">
    processItems: function() {
      this.items.each(function(item) {
        // Process item
        this.markItemAsProcessed(item);
      }.bind(this));
    }
  </pre>

  <p>The author is partially correct. In theory (and from our perspective) <code>Function.bind</code> returns a new function, so it is actually only called once as an argument to the each function, so that's not important. However, he's correct, there is an anonymous function called, then the interior <code>this.markItemAsProcessed</code> is called.</p>

  <p>His fix is to introduce the following, because it bypasses the double function call previously (via bind)</p>
  <pre class="prettyprint">
    processItems: function() {
      var that = this;
      this.items.each(function(item) {
        // Process item
        that.markItemAsProcessed(item);
      });
    }
  </pre>

  <p>Explanation is <q>This code uses a language feature called “lexical closure.” ... that it would be far less than the cost of an extra function call at every turn of the loop</q> Maybe it would be more efficient, I don't know, I rarely benchmark things of this nature, but I don't think I agree that a bound function would be <em>far less</em> effecient.</p>

  <p>From my perspective, he's written the code almost the same way twice, just finagled scope a little differently by creating a scoped variable in the second one – I'd assume old implementations of <code>bind</code> did similar things – in anywhere from a slightly to dangerously more complicated fashion. The real takeaway for me though, is that he didn't get to share the <strong>Aha!</strong> of a bound function, which is <em>clarity and elegance</em>, and in doing so, dispensed some inelegant - though not necessarily incorrect, advice.</p>

  <p>To get only one function call per loop can use binding, and that would look something like this this...</p>

  <pre class="prettyprint">
    processItems: function() {
      this.items.each(this.markItemAsProcessed.bind(this));
    }
  </pre>

  <p>He sort of took a jab at prototype and mootools, but anyone who understands the concept introduced by those frameworks (and native javascript by the time I went around to writing this critique) would (or should) do it the last way. Anyone not familiar with them should still see the elegance of that code quite easily, I hope.</p>


</article>
